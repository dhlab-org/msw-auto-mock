import { faker } from '@faker-js/faker';
import { isString, mapValues } from 'es-toolkit';
import vm from 'node:vm';
import { OpenAPIV3 } from 'openapi-types';
import path from 'path';
import { transformJSONSchemaToFakerCode, MAX_STRING_LENGTH } from './faker';
import { getResIdentifierName } from './transform';
import { TOperation, TOptions } from './types';
import { writeFile } from './utils';

interface IHandlerGenerator {
  generate(targetFolder: string): Promise<void>;
}

class HandlerGenerator implements IHandlerGenerator {
  private readonly options: TOptions;
  private readonly operationsByEntity: Record<string, TOperation[]>;
  private readonly apiDoc: OpenAPIV3.Document;

  constructor(options: TOptions, operationsByEntity: Record<string, TOperation[]>, apiDoc: OpenAPIV3.Document) {
    this.options = options;
    this.operationsByEntity = operationsByEntity;
    this.apiDoc = apiDoc;
  }

  async generate(targetFolder: string): Promise<void> {
    await this.#generateHandlersByEntity(targetFolder);
    await this.#generateCombinedHandler(targetFolder);
  }

  async #generateHandlersByEntity(targetFolder: string) {
    const codeList = mapValues(this.operationsByEntity, (operationCollection, entity) => {
      return isString(entity) ? this.#mockTemplate(operationCollection, entity) : null;
    });

    await Promise.all(
      Object.entries(codeList).map(async ([entity, code]) => {
        if (!code) return;

        await writeFile(
          path.resolve(process.cwd(), path.join(targetFolder, 'handlers'), `${entity}.handlers.ts`),
          code,
        );
      }),
    );
  }

  async #generateCombinedHandler(targetFolder: string) {
    const entityList = Object.keys(this.operationsByEntity);

    const combinedHandlers = () => {
      const handlersImport = entityList
        .map(entity => {
          return `import { ${entity}Handlers } from './${entity}.handlers';`;
        })
        .join('\n');

      const combineHandlers = `export const handlers = [
        ${entityList
          .map(entity => {
            return `...${entity}Handlers, `;
          })
          .join('\n')}
        ]`;

      return [handlersImport, combineHandlers].join('\n\n');
    };

    await writeFile(path.resolve(process.cwd(), path.join(targetFolder, 'handlers'), `index.ts`), combinedHandlers());
  }

  #mockTemplate(operationCollection: TOperation[], entity: string) {
    const baseURL = typeof this.options.baseUrl === 'string' ? this.options.baseUrl : this.#urlInDoc();

    const imports = [
      `import { HttpResponse, http, type HttpResponseResolver  } from 'msw';`,
      `import { faker } from '@faker-js/faker';`,
      `import { controllers } from '${this.options?.controllerPath ?? '@/app/mocks/controllers'}';`,
    ].join('\n');

    const apiCounters = `
      // Map to store counters for each API endpoint
      const apiCounters = new Map<string, number>();

      const next = (apiKey: string) => {
        let currentCount = apiCounters.get(apiKey) ?? 0;
        if (currentCount === Number.MAX_SAFE_INTEGER - 1) {
          currentCount = 0;
        }
        apiCounters.set(apiKey, currentCount + 1);
        return currentCount;
      };
    `;

    return `/**
      * This file is AUTO GENERATED by [msw-auto-mock](https://github.com/dhlab-org/msw-auto-mock)
      * Feel free to commit/edit it as you need.
      */
      /* eslint-disable */
      /* tslint:disable */
      // @ts-nocheck
      ${imports}
      
      faker.seed(1);
      
      const baseURL = '${baseURL}';
      ${this.options.static ? '' : `const MAX_ARRAY_LENGTH = ${this.options?.maxArrayLength ?? 20};`}
      
      ${apiCounters}
      
      export const ${entity}Handlers = [
        ${this.#handlersTemplate(operationCollection)}
      ];
      
      ${this.#resultTemplate(operationCollection, baseURL)}
      `;
  }

  #handlersTemplate(operationCollection: TOperation[]): string {
    return operationCollection
      .map(op => {
        return `http.${op.verb}(\`\${baseURL}${op.path}\`, async (info) => {
          const resultArray = [${op.response.map(response => {
            const identifier = getResIdentifierName(response);
            const status = parseInt(response?.code!);
            const responseType = response.responses ? Object.keys(response.responses)[0] : 'application/json';
            const result = `{
              status: ${status},
              responseType: ${status === 204 ? 'undefined' : `'${responseType}'`},
              body: ${status === 204 ? 'undefined' : `${identifier ? `await ${identifier}(info)` : 'undefined'}`}
            }`;

            return result;
          })}];
  
          const selectedResult = resultArray[next(\`${op.verb} ${op.path}\`) % resultArray.length]
          
          return new HttpResponse(JSON.stringify(selectedResult.body), {
            status: selectedResult.status,
            headers: {
              'Content-Type': selectedResult.responseType
            }
          })
        }),\n`;
      })
      .join('  ')
      .trimEnd();
  }

  #resultTemplate(operationCollection: TOperation[], baseURL: string) {
    const context = {
      faker,
      MAX_STRING_LENGTH,
      MAX_ARRAY_LENGTH: this.options?.maxArrayLength ?? 20,
      baseURL: baseURL ?? '',
      result: null,
    };
    vm.createContext(context);

    return operationCollection
      .map(op =>
        op.response
          .map(r => {
            const name = getResIdentifierName(r);
            if (!name) {
              return '';
            }

            if (!r.responses) {
              return;
            }

            const isCustomResponse = Object.keys(this.options?.controllers ?? {}).includes(name);
            if (isCustomResponse) {
              return [
                `export function ${name}(info: Parameters<HttpResponseResolver>[0]) {`,
                `  return controllers.${name}(info);`,
                `};\n`,
              ].join('\n');
            }

            const jsonResponseKey = Object.keys(r.responses).filter(r => r.startsWith('application/json'))[0];
            const fakerResult = transformJSONSchemaToFakerCode(r.responses?.[jsonResponseKey]);
            if (this.options?.static) {
              vm.runInContext(`result = ${fakerResult};`, context);
            }

            return [
              `export function `,
              `${name}() { `,
              `return ${this.options?.static ? JSON.stringify(context.result) : fakerResult} `,
              `};\n`,
            ].join('\n');
          })
          .join('\n'),
      )
      .join('\n');
  }

  #urlInDoc() {
    let server = this.apiDoc.servers?.at(0);
    let url = '';
    if (server) {
      url = server.url;
    }
    if (server?.variables) {
      Object.entries(server.variables).forEach(([key, value]) => {
        url = url.replace(`{${key}}`, value.default);
      });
    }

    return url;
  }
}

export { HandlerGenerator };
