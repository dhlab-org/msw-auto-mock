import { faker } from '@faker-js/faker';
import { camelCase } from 'es-toolkit';
import vm from 'node:vm';
import { MAX_STRING_LENGTH, transformJSONSchemaToFakerCode } from '../faker';
import { TOperation, TResponse } from '../types';

type TemplateContract = {
  ofEntity(entityOperations: TOperation[], entity: string, context: TContext): string;
  ofAllCombined(entities: string[]): string;
};

class HandlerTemplate implements TemplateContract {
  ofEntity(entityOperations: TOperation[], entity: string, context: TContext): string {
    const imports = this.#imports(context);
    const apiCounter = this.#apiCounter();
    const hasStreamingResponse = this.#hasStreamingResponse(entityOperations);
    const streamingUtils = hasStreamingResponse ? this.#streamingUtils() : '';
    const handlers = this.#handlers(entityOperations);
    const resultFunctions = this.#resultFunctions(entityOperations, context);

    return `/**
      * This file is AUTO GENERATED by [msw-auto-mock](https://github.com/dhlab-org/msw-auto-mock)
      * Feel free to commit/edit it as you need.
      */
      /* eslint-disable */
      /* tslint:disable */
      // @ts-nocheck
      ${imports}
      
      faker.seed(1);
      
      const baseURL = '${context.baseURL}';
      ${context.isStatic ? '' : `const MAX_ARRAY_LENGTH = ${context.maxArrayLength};`}
      
      ${apiCounter}
      ${streamingUtils}

      export const ${entity}Handlers = [
        ${handlers}       
      ];
      
      ${resultFunctions}
      `;
  }

  ofAllCombined(entities: string[]): string {
    const handlersImport = entities
      .map(entity => `import { ${entity}Handlers } from './${entity}.handlers';`)
      .join('\n');

    const combineHandlers = `export const handlers = [
      ${entities.map(entity => `...${entity}Handlers,`).join('\n')}
    ]`;

    return [handlersImport, combineHandlers].join('\n\n');
  }

  #imports(context: TContext): string {
    return [
      `import { HttpResponse, http, type HttpResponseResolver } from 'msw';`,
      `import { faker } from '@faker-js/faker';`,
      `import { controllers } from '${context.controllerPath}';`,
      `import type { TStreamingEvent } from '@dataai/msw-auto-mock';`,
    ].join('\n');
  }

  #apiCounter(): string {
    return `
      // Map to store counters for each API endpoint
      const apiCounters = new Map<string, number>();

      const next = (apiKey: string) => {
        let currentCount = apiCounters.get(apiKey) ?? 0;
        if (currentCount === Number.MAX_SAFE_INTEGER - 1) {
          currentCount = 0;
        }
        apiCounters.set(apiKey, currentCount + 1);
        return currentCount;
      };
    `;
  }

  #hasStreamingResponse(entityOperations: TOperation[]): boolean {
    return entityOperations.some(op =>
      op.response.some(response => response.responses && Object.keys(response.responses).includes('text/event-stream')),
    );
  }

  #streamingUtils(): string {
    return `
      // streaming response utility
      function createStreamingResponse(messages: TStreamingEvent[]) {
        const encoder = new TextEncoder();
        const stream = new ReadableStream({
          async start(controller) {
            for (const chunk of messages) {
              if (chunk.delay) {
                await new Promise((resolve) => setTimeout(resolve, chunk.delay));
              }
              controller.enqueue(
                encoder.encode(\`event: \${chunk.event}\\n\${chunk.data ? \`data: \${chunk.data}\\n\` : ''}\\n\`)
              );
            }
            controller.close();
          },
        });
        return stream;
      }
    `;
  }

  #handlers(entityOperations: TOperation[]): string {
    return entityOperations
      .map(op => this.#handler(op))
      .join('\n')
      .trimEnd();
  }

  #handler(op: TOperation): string {
    return `
    http.${op.verb}(\`\${baseURL}${op.path}\`, async (info) => {
      const resultArray = [${op.response.map(response => this.#responseObject(response))}];
      const selectedResult = resultArray[next(\`${op.verb} ${op.path}\`) % resultArray.length];
    
      return new HttpResponse(selectedResult.body, {
        status: selectedResult.status,
        headers: selectedResult.responseType ? {
          'Content-Type': selectedResult.responseType
        } : undefined
      });
    }),\n`;
  }

  #responseObject(response: TResponse): string {
    const identifier = response.id ? camelCase(`get_${response.id}_${response.code}_response`) : '';
    const status = parseInt(response?.code!);
    const hasResponseBody = status !== 204 && status < 300; // 성공(2xx) 응답 중 204만 제외
    const responseType = hasResponseBody && response.responses ? Object.keys(response.responses)[0] : undefined;
    const isStreamingResponse = responseType === 'text/event-stream';

    const body = (() => {
      if (!hasResponseBody) return 'undefined';
      if (isStreamingResponse) return `createStreamingResponse(await ${identifier}(info))`;
      return identifier ? `await ${identifier}(info)` : 'undefined';
    })();

    return `{
      status: ${status},
      responseType: ${responseType ? `'${responseType}'` : undefined},
      body: ${body === 'undefined' || isStreamingResponse ? body : `JSON.stringify(${body})`}
    }`;
  }

  #resultFunctions(entityOperations: TOperation[], context: TContext): string {
    const vmContext: VMContext = {
      faker,
      MAX_STRING_LENGTH,
      MAX_ARRAY_LENGTH: context.maxArrayLength,
      baseURL: context.baseURL,
      result: null,
    };
    vm.createContext(vmContext);

    return entityOperations
      .map(op => op.response.map(r => this.#resultFunction(r, context, vmContext)).join('\n'))
      .join('\n');
  }

  #resultFunction(response: TResponse, context: TContext, vmContext: VMContext): string {
    const name = response.id ? camelCase(`get_${response.id}_${response.code}_response`) : '';
    if (!response.responses) return '';

    const isCustomResponse = Object.keys(context.controllers).includes(name);
    if (isCustomResponse) {
      return `
        export function ${name}(info: Parameters<HttpResponseResolver>[0]) {
          return (controllers as Required<typeof controllers>).${name}(info);
        };
      `;
    }

    const jsonResponseKey = Object.keys(response.responses).find(r => r.startsWith('application/json'));
    if (!jsonResponseKey) return '';

    const fakerResult = transformJSONSchemaToFakerCode(response.responses[jsonResponseKey]);
    if (context.isStatic) {
      vm.runInContext(`result = ${fakerResult};`, vmContext);
    }

    const data = context.isStatic ? JSON.stringify(vmContext.result) : fakerResult;

    return `
      export function ${name}() {
        return ${data};
      };
    `;
  }
}

export { HandlerTemplate, type TemplateContract as HandlerTemplateContract, type TContext };

type TContext = {
  baseURL: string;
  controllerPath: string;
  isStatic: boolean;
  maxArrayLength: number;
  controllers: Record<string, unknown>;
};

type VMContext = {
  faker: typeof faker;
  MAX_STRING_LENGTH: number;
  MAX_ARRAY_LENGTH: number;
  baseURL: string;
  result: unknown;
};
