import { faker } from '@faker-js/faker';
import vm from 'node:vm';
import { MAX_STRING_LENGTH, transformJSONSchemaToFakerCode } from '../faker';
import { getResIdentifierName } from '../transform';
import { TOperation } from '../types';

type TemplateContract = {
  ofEntity(entityOperations: TOperation[], entity: string, context: TContext): string;
  ofAllCombined(entities: string[]): string;
};

type TContext = {
  baseURL: string;
  controllerPath: string;
  isStatic: boolean;
  maxArrayLength: number;
  controllers: Record<string, unknown>;
};

class HandlerTemplate implements TemplateContract {
  ofEntity(entityOperations: TOperation[], entity: string, context: TContext) {
    const imports = [
      `import { HttpResponse, http, type HttpResponseResolver  } from 'msw';`,
      `import { faker } from '@faker-js/faker';`,
      `import { controllers } from '${context.controllerPath}';`,
    ].join('\n');

    const apiCounters = `
      // Map to store counters for each API endpoint
      const apiCounters = new Map<string, number>();

      const next = (apiKey: string) => {
        let currentCount = apiCounters.get(apiKey) ?? 0;
        if (currentCount === Number.MAX_SAFE_INTEGER - 1) {
          currentCount = 0;
        }
        apiCounters.set(apiKey, currentCount + 1);
        return currentCount;
      };
    `;

    return `/**
      * This file is AUTO GENERATED by [msw-auto-mock](https://github.com/dhlab-org/msw-auto-mock)
      * Feel free to commit/edit it as you need.
      */
      /* eslint-disable */
      /* tslint:disable */
      // @ts-nocheck
      ${imports}
      
      faker.seed(1);
      
      const baseURL = '${context.baseURL}';
      ${context.isStatic ? '' : `const MAX_ARRAY_LENGTH = ${context.maxArrayLength};`}
      
      ${apiCounters}
      
      export const ${entity}Handlers = [
        ${this.#handlersTemplate(entityOperations)}
      ];
      
      ${this.#resultTemplate(entityOperations, context)}
      `;
  }

  ofAllCombined(entities: string[]): string {
    const handlersImport = entities
      .map(entity => {
        return `import { ${entity}Handlers } from './${entity}.handlers';`;
      })
      .join('\n');

    const combineHandlers = `export const handlers = [
      ${entities
        .map(entity => {
          return `...${entity}Handlers, `;
        })
        .join('\n')}
      ]`;

    return [handlersImport, combineHandlers].join('\n\n');
  }

  #handlersTemplate(entityOperations: TOperation[]): string {
    return entityOperations
      .map(op => {
        return `http.${op.verb}(\`\${baseURL}${op.path}\`, async (info) => {
          const resultArray = [${op.response.map(response => {
            const identifier = getResIdentifierName(response);
            const status = parseInt(response?.code!);
            const responseType = response.responses ? Object.keys(response.responses)[0] : 'application/json';
            const result = `{
              status: ${status},
              responseType: ${status === 204 ? 'undefined' : `'${responseType}'`},
              body: ${status === 204 ? 'undefined' : `${identifier ? `await ${identifier}(info)` : 'undefined'}`}
            }`;

            return result;
          })}];
  
          const selectedResult = resultArray[next(\`${op.verb} ${op.path}\`) % resultArray.length]
          
          return new HttpResponse(JSON.stringify(selectedResult.body), {
            status: selectedResult.status,
            headers: {
              'Content-Type': selectedResult.responseType
            }
          })
        }),\n`;
      })
      .join('  ')
      .trimEnd();
  }

  #resultTemplate(entityOperations: TOperation[], context: TContext) {
    const vmContext = {
      faker,
      MAX_STRING_LENGTH,
      MAX_ARRAY_LENGTH: context.maxArrayLength,
      baseURL: context.baseURL,
      result: null,
    };
    vm.createContext(vmContext);

    return entityOperations
      .map(op =>
        op.response
          .map(r => {
            const name = getResIdentifierName(r);
            if (!name) {
              return '';
            }

            if (!r.responses) {
              return;
            }

            const isCustomResponse = Object.keys(context.controllers).includes(name);
            if (isCustomResponse) {
              return [
                `export function ${name}(info: Parameters<HttpResponseResolver>[0]) {`,
                `  return controllers.${name}(info);`,
                `};\n`,
              ].join('\n');
            }

            const jsonResponseKey = Object.keys(r.responses).filter(r => r.startsWith('application/json'))[0];
            const fakerResult = transformJSONSchemaToFakerCode(r.responses?.[jsonResponseKey]);
            if (context.isStatic) {
              vm.runInContext(`result = ${fakerResult};`, vmContext);
            }

            return [
              `export function `,
              `${name}() { `,
              `return ${context.isStatic ? JSON.stringify(vmContext.result) : fakerResult} `,
              `};\n`,
            ].join('\n');
          })
          .join('\n'),
      )
      .join('\n');
  }
}

export { HandlerTemplate, type TemplateContract as HandlerTemplateContract, type TContext };
